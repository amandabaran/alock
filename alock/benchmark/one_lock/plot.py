from enum import Enum
from math import ceil
from absl import flags
from absl import app
import math
import os
import google.protobuf.text_format as text_format
import google.protobuf.descriptor as descriptor
import alock.benchmark.one_lock.experiment_pb2 as experiment
from alive_progress import alive_bar
import pandas
import matplotlib.pyplot as plt
import seaborn
from rome.rome.util.debugpy_util import debugpy_hook

pandas.options.mode.chained_assignment = None  # default='warn'


flags.DEFINE_string("figdir", '/Users/amandabaran/Desktop/sss/async_locks/alock/alock/alock/benchmark/one_lock/plots/',
                    "Directory name to save figures under")
flags.DEFINE_string(
    'datafile', None,
    'Name of datafile for plotting (if none exists then one is generated by processing results in `save_dir`)')

flags.DEFINE_string('exp', 'exp1', 'Experiment to plot')

FLAGS = flags.FLAGS

def getData(proto, path=''):
    data = {}
    for field in proto.DESCRIPTOR.fields:
        is_repeated = field.label == descriptor.FieldDescriptor.LABEL_REPEATED
        is_empty_repeated = (is_repeated and len(
            getattr(proto, field.name)) == 0)
        is_missing = (not field.label == descriptor.FieldDescriptor.
                      LABEL_REPEATED and not proto.HasField(field.name))
        if is_empty_repeated or is_missing:
            continue
        if not is_repeated and field.type is descriptor.FieldDescriptor.TYPE_MESSAGE:
            data.update(getData(
                getattr(proto, field.name),
                path + ('.' if len(path) != 0 else '') + field.name))
        elif is_repeated and field.type is descriptor.FieldDescriptor.TYPE_MESSAGE:
            repeated = []
            for f in getattr(proto, field.name):
                repeated.append(
                    getData(
                        f, path + ('.' if len(path) != 0 else '') +
                        field.name))
            result = {}
            for r in repeated:
                for k in r.keys():
                    if not k in result.keys():
                        result[k] = [r[k]]
                    else:
                        result[k].append(r[k])
            # data |= result
            data.update(result)
        else:
            data[path + ('.' if len(path) !=
                         0 else '') + field.name] = getattr(proto, field.name)
    return data

def generate_csv(results_dir, datafile):
    assert(os.path.exists(results_dir))
    result_files = os.walk(results_dir)
    results_protos = []
    data_files = []
    # builds list of data files to read
    for root, _, files in result_files:
        if len(files) == 0:
            continue
        for name in files:
            data_files.append(os.path.join(root, name))

    # combines ResultsProto from each data file into list
    with alive_bar(len(data_files), title="Reading data...") as bar:
        for f in data_files:
            with open(f) as result_file:
                results = text_format.Parse(
                    result_file.read(), experiment.ResultsProto())
                results_protos.append(results)
                bar()

    results = []
    with alive_bar(len(results_protos), title="Preparing data...") as bar:
        for proto in results_protos:
            results.append(getData(proto))
            bar()
    data = pandas.DataFrame()
    dfs = []
    with alive_bar(len(results), title="Generating datafile: {}".format(datafile)) as bar:
        for r in results[:-1]:
            dfs.append(pandas.DataFrame([r]))
            bar()
        dfs.append(pandas.DataFrame(results[-1]))
        bar.text = "Aggregating final data..."
        data = pandas.concat(dfs, ignore_index=True)
        bar()
    data.to_csv(datafile, index_label='row')

def merge_csv(csv1, csv2):
    df1 = pandas.read_csv(csv1)
    df2 = pandas.read_csv(csv2)
    frames = [df1, df2]
    data = pandas.concat(frames)
    data.to_csv(csv1, index_label='row')
    return data
    
# Globals
x1_ = 'lock_type'
x2_ = 'experiment_params.workload.max_key'
x3_ = 'experiment_params.num_clients'
x4_ = 'experiment_params.num_nodes'
x5_ = 'experiment_params.workload.p_local'
x6_ = 'experiment_params.local_budget'
x7_ = 'experiment_params.remote_budget'
x8_ = 'experiment_params.num_threads'
x_ = [x1_, x2_, x3_, x4_, x5_, x6_, x7_, x8_]
y_ = 'results.driver.qps.summary.mean'
cols_ = [x1_, x2_, x3_, x4_, x5_, x6_, x7_, x8_, y_]

def get_summary(data):
    # Calculate totals grouped by the cluster size
    grouped = data.groupby(x_, as_index=True)[y_]
    _avg = grouped.mean()
    _stddev = grouped.std()
    _max = grouped.max()
    _min = grouped.min()
    _total = grouped.sum()
    summary = pandas.DataFrame(index=grouped.groups.keys())
    summary.index.names = x_
    summary['average'] = _avg
    summary['stddev'] = _stddev
    summary['min'] = _min
    summary['max'] = _max
    summary['total'] = _total
    print("\n\n----------------SUMMARY------------------\n")
    print(summary)
    return summary

def plot_budget(nodes, plocal, summary, name):
    global x6_, x7_, y_
    
    local_budgets = [5, 10, 20, 30]
            
    # make a grid of subplots with a row for each node number and a column for each key setup
    # add 1 to len(keys) for final column of 100p% local for each node config
    fig1, axes1 = plt.subplots(len(local_budgets), len(plocal), figsize=(8, 8))
    fig2, axes2 = plt.subplots(len(local_budgets), len(plocal), figsize=(8, 8))
    seaborn.set_theme(style='ticks')
    markersize = 10
    
    # reset index in order to access all fields for hue
    summary = summary.reset_index()
    
    # save original data
    original = summary
    
    #filter data to only include alocks
    alock = summary[summary['lock_type'] == 'ALock']
    alock = alock.reset_index(drop=True)

    fig2.subplots_adjust(hspace = 1.2, wspace = 0.35)
    
    # Remote Plots
    for i, budget in enumerate(local_budgets):
        for j, pl in enumerate(plocal):
            data = alock[alock['experiment_params.workload.p_local'] == pl]
            data = data[data['experiment_params.num_nodes'] == 20]
            data = data[data['experiment_params.local_budget'] == budget]
            data = data.reset_index(drop=True)
            seaborn.lineplot(
                    data=data,
                    x=x7_,
                    y='total',
                    ax=axes1[i][j],
                    hue='experiment_params.workload.max_key',
                    style='experiment_params.num_clients',
                    markers=True,
                    markersize=markersize,
                    palette="colorblind",
            )
            # set y axis to start at 0
            axes1[i][j].set_ylim(0, axes1[i][j].get_ylim()[1])  
            h2, l2 = axes1[i][j].get_legend_handles_labels()
            axes1[i][j].set_ylabel('') 
            axes1[i][j].set_xlabel('Remote Budget', fontsize=7)
            axes1[i][j].set_title(str(int((pl*100))) + " % Local, Local Budget = " + str(budget), fontsize=9)
            # axes[i][j].title.set_size(8)
            axes1[i][j].set_ylabel('Aggregated T-put (ops/s)', labelpad=20, fontsize=7)
        
    fig1.subplots_adjust(hspace = 1, wspace = 0.35)    
    for i, budget in enumerate(local_budgets):
        for j, pl in enumerate(plocal):
            data = alock[alock['experiment_params.workload.p_local'] == pl]
            data = data[data['experiment_params.num_nodes'] == 20]
            data = data[data['experiment_params.remote_budget'] == budget]
            data = data.reset_index(drop=True)
            seaborn.lineplot(
                    data=data,
                    x=x6_,
                    y='total',
                    ax=axes2[i][j],
                    hue='experiment_params.workload.max_key',
                    style='experiment_params.num_clients',
                    markers=True,
                    markersize=markersize,
                    palette="colorblind",
            )
            # set y axis to start at 0
            axes2[i][j].set_ylim(0, axes2[i][j].get_ylim()[1])  
            h3, l3 = axes2[i][j].get_legend_handles_labels()
            axes2[i][j].set_ylabel('') 
            axes2[i][j].set_xlabel('Local Budget', fontsize=7)
            axes2[i][j].set_title(str(int((pl*100))) + " % Local, Remote Budget = " + str(budget), fontsize=9)
            # axes[i][j].title.set_size(8)
            axes2[i][j].set_ylabel('Aggregated T-put (ops/s)', labelpad=20, fontsize=7)


    # Legend creation
    # This is a hacky way to change the labels in the legend
    l2[0] = 'Keys'
    l2[4] = 'Clients'
    
    for h in h2:
        h.set_markersize(24)
        h.set_linewidth(3)
        
    for h in h3:
        h.set_markersize(24)
        h.set_linewidth(3)
        
    for ax in axes1.flatten():
        ax.legend().remove()
    for ax in axes2.flatten():
        ax.legend().remove()

    legend1 = fig1.legend(h2, l2, bbox_to_anchor=(.5, 1.15),
        loc='upper center', fontsize=8, title_fontsize=10, title='Legend', markerscale=.3,
        ncol=2, columnspacing=1, edgecolor='white', borderpad=1)
    
    legend2 = fig2.legend(h3, l3, bbox_to_anchor=(.5, 1.15),
        loc='upper center', fontsize=8, title_fontsize=10, title='Legend', markerscale=.3,
        ncol=2, columnspacing=1, edgecolor='white', borderpad=1)
    
    plt.show()
    
    filename_remote = name + "_remote" + ".png"
    filename_local = name + "_local" + ".png"
    dirname = os.path.dirname(name)
    os.makedirs(dirname, exist_ok=True)
    
    fig1.savefig(os.path.join(dirname, filename_remote), dpi=300, bbox_extra_artists=(legend1,)
                if legend1 is not None else None, bbox_inches='tight')
    fig2.savefig(os.path.join(dirname, filename_local), dpi=300, bbox_extra_artists=(legend2,)
                if legend2 is not None else None, bbox_inches='tight')
   
    
            
def plot_throughput(xcol, originals, summary, hue, xlabel, hue_label, name):
    global x1_, x2_, x3_, y_
    # make a grid of subplots with r X c plots of size figsize
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 5))
    seaborn.set_theme(style='ticks')
    markersize = 8

    if hue != None:
        num_hues = len(summary.reset_index()[hue].dropna().unique())
    else:
        num_hues = 1
    palette = seaborn.color_palette("viridis", num_hues)
    per = seaborn.lineplot(
        data=originals,
        x=xcol,
        y=y_,
        ax=ax1,
        hue=hue,
        style=hue,
        markers=True,
        markersize=markersize,
        # errorbar='sd',
        palette=palette
    )
    totals = seaborn.lineplot(
        data=summary,
        x=xcol,
        y='total',
        ax=ax2,
        hue=hue,
        style=hue,
        markers=True,
        markersize=markersize,
        palette=palette
    )

    font = {'fontsize': 24}
    for ax in ax1, ax2:
        ax.ticklabel_format(axis='y', scilimits=[-5, 3])
        ax.yaxis.get_offset_text().set_fontsize(24)
        ax.yaxis.set_major_locator(plt.MaxNLocator(5))
        ax.tick_params(labelsize=24)
        ax.set_ylim(ymin=0)

    ax1.set_title('Per-client', font)
    ax1.set_ylabel('Throughput (ops/s)', font, labelpad=20)
    ax1.set_xlabel(xlabel, font)
    # ax1.invert_xaxis()
    ax1.set_ylim(1.5e3)
    
    ax2.set_title('Total', font)
    ax2.set_ylabel('', font)
    ax2.set_xlabel(xlabel, font)
    # ax2.invert_xaxis()
    ax2.set_ylim(2e5)
    
    # h1, l1 = totals.get_legend_handles_labels()
    h2, l2 = ax1.get_legend_handles_labels()
    for h in h2:
        h.set_markersize(24)
        h.set_linewidth(3)
    labels_handles = {}
    # labels_handles.update(dict(zip(l1, h1)))
    labels_handles.update(dict(zip(l2, h2)))
    totals.legend().remove()
    per.legend().remove()
    legend = None
    if num_hues != 1:
        legend = fig.legend(
            h2, l2, bbox_to_anchor=(.5, 1.27),
            loc='center', fontsize=24, title_fontsize=24, title=hue_label,
            ncol=num_hues if num_hues < 6 else int(num_hues / 2),
            # ncol=int(num_hues / 2),
            columnspacing=1, edgecolor='white', borderpad=0)

    filename = name + ".png"
    dirname = os.path.dirname(filename)
    os.makedirs(dirname, exist_ok=True)
    fig.savefig(filename, dpi=300, bbox_extra_artists=(legend,)
                if legend is not None else None, bbox_inches='tight')


def plot_p50(data):
    print("Plotting latency...")
    
    columns = ['lock_type', 'experiment_params.num_clients', 'experiment_params.num_nodes', 
               'experiment_params.workload.max_key', 'experiment_params.workload.p_local',
               'experiment_params.remote_budget', 'experiment_params.local_budget', 
               'results.driver.latency.summary.p50']
    data = data[columns]
    
    data['results.driver.latency.summary.p50'] = data['results.driver.latency.summary.p50'].apply(lambda s: [float(x.strip()) for x in s.strip(' []').split(',')])
    data = data.explode('results.driver.latency.summary.p50')
    # reset index number to label each row
    data = data.reset_index(drop=True)
    print(data)

def plot_locality_lines(nodes, keys, summary, name):
    global x8_, y_
            
    # make a grid of subplots with a row for each node number and a column for each key setup
    # add 1 to len(keys) for final column of 100p% local for each node config
    fig, axes = plt.subplots(len(nodes), len(keys), figsize=(14, 7))
    seaborn.set_theme(style='ticks')
    markersize = 10
    
    

    # reset index in order to access all fields for hue
    summary = summary.reset_index()
    
    # save original data
    original = summary

    #filter data to only include desire p_local lines
    plocal = [.75, .5]
    summary = summary[summary['experiment_params.workload.p_local'].isin(plocal)]
    summary = summary.reset_index(drop=True)
    
    #filter data to only include desire remote_budget data for alocks only
    # budget = [20]
    # alock = summary[summary['lock_type'] == 'ALock']
    # other = summary[summary['lock_type'] != "ALock"]
    # alock = alock[alock['experiment_params.remote_budget'].isin(budget)]
    # alock = alock.reset_index(drop=True)
    # # rejoin data to plot competitors (since budget is irrelevant to them)
    # summary = pandas.concat([alock, other])

    plt.subplots_adjust(hspace = 0, wspace = 0.25)
    # phttps://file+.vscode-resource.vscode-cdn.net/Users/amandabaran/Desktop/sss/async_locks/alock/alock/alock/benchmark/one_lock/plots/alock_budgets/local_v_remote.png?version%3D1705252647573lt.subplots_adjust(wspace = 0.25)
    

    for i, node in enumerate(nodes):
        for j, key in enumerate(keys):
            data = summary[summary['experiment_params.workload.max_key'] == key]
            data = data[data['experiment_params.num_nodes'] == node]
            data = data.reset_index(drop=True)
            seaborn.lineplot(
                    data=data,
                    x=x8_,
                    y='total',
                    ax=axes[i][j],
                    hue='lock_type',
                    style='experiment_params.workload.p_local',
                    markers=True,
                    markersize=markersize,
                    palette="colorblind",
            )
            # set y axis to start at 0
            axes[i][j].set_ylim(0, axes[i][j].get_ylim()[1])
            # set 3 ticks on y axis with values auto-chosen
            # axes[i][j].set_yticks(axes[i][j].get_yticks()[::len(axes[i][j].get_yticks()) // 3])
            h2, l2 = axes[i][j].get_legend_handles_labels()
            print(l2)
            axes[i][j].set_ylabel('') 
            axes[i][j].set_xlabel('Threads per Node')
            axes[i][j].set_title(str(key) + " Keys, " + str(node) + " Nodes")
        axes[i][0].set_ylabel('Aggregated Throughput (ops/s)', labelpad=20)

    # # Add final column with 100p local by filtering original data again
    # p100 = original[original['experiment_params.workload.p_local'] == 1.0]
    # p100 = p100[p100['experiment_params.remote_budget'] == 5]
    # p100 = p100.reset_index(drop=True)
    
    # # plot final column with 100p local
    # for i, node in enumerate(nodes):
    #     # data = p100[p100['experiment_params.workload.max_key'] == 100]
    #     data = p100
    #     data = data[data['experiment_params.num_nodes'] == node]
    #     data = data.reset_index(drop=True)
    #     seaborn.lineplot(
    #             data=data,
    #             x=x8_,
    #             y='total',
    #             ax=axes[i][len(keys)],
    #             hue='lock_type',
    #             style='experiment_params.workload.max_key',
    #             markers=True,
    #             markersize=markersize,
    #             palette="magma",
    #     )
    #     # set y axis to start at 0
    #     axes[i][len(keys)].set_ylim(0, axes[i][len(keys)].get_ylim()[1])
    #     # set 3 ticks on y axis with values auto-chosen
    #     # axes[i][j].set_yticks(axes[i][j].get_yticks()[::len(axes[i][j].get_yticks()) // 3])
    #     h3, l3 = axes[i][len(keys)].get_legend_handles_labels()
    #     axes[i][len(keys)].set_ylabel('') 
    #     axes[i][len(keys)].set_xlabel('Threads per Node')
    #     axes[i][len(keys)].set_title("100% Local, " + str(node) + " Nodes")
       
    
     
    # Legend creation
    # This is a hacky way to change the labels in the legend
    l2[0] = 'Lock Type'
    l2[4] = 'Percent Local'
    for h in h2:
        h.set_markersize(24)
        h.set_linewidth(3)
    labels_handles = {}
    labels_handles.update(dict(zip(l2, h2)))
    
    for ax in axes.flatten():
        ax.legend().remove()
    
    legend1 = fig.legend(h2, l2, bbox_to_anchor=(.45, 1.1),
        loc='upper center', fontsize=9, title_fontsize=11, title='Legend', markerscale=.3,
        ncol=2, columnspacing=1, edgecolor='white', borderpad=1)
    
    # Legend for 100p plot
    # This is a hacky way to change the labels in the legend
    # l3[0] = 'Lock Type'
    # l3[4] = 'Keys'
    # for h in h3:
    #     h.set_markersize(24)
    #     h.set_linewidth(3)
    # labels_handles = {}
    # labels_handles.update(dict(zip(l3, h3)))
    
    # for ax in axes.flatten():
    #     ax.legend().remove()
    
    # legend2 = fig.legend(h3, l3, bbox_to_anchor=(.9, 1.1),
    #     loc='upper right', fontsize=9, title_fontsize=11, title='100% Local Legend', markerscale=.3,
    #     ncol=2, columnspacing=1, edgecolor='white', borderpad=1)

    filename = name + ".png"
    dirname = os.path.dirname(filename)
    os.makedirs(dirname, exist_ok=True)
    fig.savefig(filename, dpi=300, bbox_extra_artists=(legend1,)
                if legend1 is not None else None, bbox_inches='tight')
    # fig.savefig(filename, dpi=300, bbox_extra_artists=(legend1, legend2)
    #             if legend1 or legend2 is not None else None, bbox_inches='tight')
   
    # plt.tight_layout()
    # plt.show()

def plot(datafile, lock_type):
    data = pandas.read_csv(datafile)
    # datafile2 = "/Users/amandabaran/Desktop/sss/async_locks/alock/alock/alock/benchmark/one_lock/plots/5node_localp.csv"
    # if os.path.exists(datafile2) :
    #     data = merge_csv(datafile, datafile2)
    # else:
    #     data = pandas.read_csv(datafile)
               
    alock = data[data['experiment_params.name'].str.count("alock.*") == 1]
    alock['lock_type'] = 'ALock'
    mcs = data[data['experiment_params.name'].str.count("mcs.*") == 1]
    mcs['lock_type'] = 'MCS'
    spin = data[data['experiment_params.name'].str.count("spin.*") == 1]
    spin['lock_type'] = 'Spin'
 
    data = pandas.concat([alock, mcs, spin])
    # plot_p50(data)
    columns = ['lock_type', 'experiment_params.num_threads', 'experiment_params.num_clients', 'experiment_params.num_nodes', 
               'experiment_params.workload.max_key', 'experiment_params.workload.p_local', 
               'experiment_params.remote_budget', 'experiment_params.local_budget', 'results.driver.qps.summary.mean']
    data = data[columns]
    print(data)
    data['results.driver.qps.summary.mean'] = data['results.driver.qps.summary.mean'].apply(
        lambda s: [float(x.strip()) for x in s.strip(' []').split(',')])
    data = data.explode('results.driver.qps.summary.mean')
    data = data.reset_index(drop=True)

    summary = get_summary(data)
 
    # data = alock
    # plot_throughput(x1_, data, summary, 'lock_type', 'Clients', 'Lock type', os.path.join(FLAGS.figdir, FLAGS.exp, 'n2_m10'))
    
    # plot_grid(nodes, keys, x3_, data, summary, 'lock_type', 'Clients', 'Lock type', os.path.join(FLAGS.figdir, FLAGS.exp, 'alock_spin'), False)
    
    nodes = [5, 10]
    keys = [20, 100, 1000]
    # clients = [40, 120, 180]
    # p_local = [.3, .5, .8]
    # plot_budget(nodes, keys, clients, p_local, data, summary, 'lock_type', 'Remote Budget', 'Lock type', os.path.join(FLAGS.figdir, FLAGS.exp, 'local_budget'), False)

    plot_locality_lines(nodes, keys, summary, os.path.join(FLAGS.figdir, FLAGS.exp, 'test'))
    
    # plocal = [1.0, .95, .85]
    # plot_budget(nodes, plocal, summary, os.path.join(FLAGS.figdir, FLAGS.exp, 'local_v_remote20'))
 